# 날짜: 2025-03-20

## 새로 배운 내용
### 주제 1: Transaction
#### 개념
- 데이터베이스에서의 상호작용의 단위
- 데이터베이스의 무결성과 일관성을 보장
- 여러 작업을 하나의 논리적인 작업 단위로 묶어서 처리

#### 상태
- Active: 데이터베이스 명령을 받고, 실행하는 중
- Partially committed: 명령 실행 완료, Commit만을 기다리는 중
- Aborted: 트랜잭션을 취소하고 이전으로 돌아감
- Failed: 오류, 예외가 발생하여 더 진행할 수 없는 상황
- Committed: 트랜잭션 완료, 변경사항이 DB에 반영됨

#### ACID
- Atomicity: 트랜잭션은 완전히 수행되거나, 전혀 수행되지 않아야 한다
- Consistenty: 트랜잭션 전후로 DB의 제약은 항상 만족한다
- Isolation: 여러 트랜잭션이 있을 때 서로 간섭할 수 없다
- Durability: 트랜잭션 완료 시, 해당 사항은 영구적으로 반영된다

#### 실제 코드에서
<pre>
START TRANSACTION;
# 작업 내용
COMMIT;
</pre>

<pre>
START TRANSACTION;
# 작업 내용
ROLLBACK;
</pre>

---

### 주제 2: Isolation level
#### Level 0 - Read Uncommitted
- 트랜잭션의 Commit / Rollback 전에도 데이터 읽기 가능
- 남이 작성중인, 확정되지 않는 데이터를 읽는 Dirty Read 문제 발생

#### Level 1 - Read Committed
- 트랜잭션의 Commit 후에만 데이터 읽기 가능
- 데이터 조회 시 실제 값이 아닌 백업된 레코드를 읽는다
- 그러나 트랜잭션 도중 Commit이 완료되는 것은 가능
- 같은 데이터를 2번 읽었는데 다른 값이 나오는 Non-repeatable Read 문제

#### Level 2 - Repeatable Read
- 트랜잭션 시작 이전에 Commit된 데이터 수정만 조회 가능
- 그러나 새로운 데이터 삽입 / 삭제는 막지 않는다
- 트랜잭션 도중 데이터 개수가 바뀌는 Phantom Read 문제

#### Level 3 - Serializable
- 트랜잭션의 동시성을 완전히 막아버렸기에 아무 문제가 발생하지 않는다
- 그러나 성능 저하가 심할 수 있다. 특수한 경우가 아니면 사용하지 않음

---

### 주제 3: NoSQL
#### 개념
- 이미지 등 비구조적 데이터를 스키마 없이 저장
- RDBMS와 비교해, 효율적으로 확장이 가능함
- 다양한 데이터 모델(키-값, 그래프, 등)을 지원한다
- 여러 서버에 분산 저장하여 읽기 / 쓰기가 빠르고, 빅데이터 관리에 사용

#### 유형
- 키값: 해싱을 이용, 읽고 쓰기가 빠르지만 복잡한 데이터 관계 처리는 힘들다
- 문서: JSON 등 문서 형식으로 저장해, 스카마가 유연하지만 데이터 간 관계성이 약함
- 행렬: 대규모 데이터 분석과 뛰어난 확장성, 그러나 단순 조회의 성능 저하
- 그래프: 데이터 간 관계를 잘 탐색 가능, 그러나 대규모 데이터에서 성능 저하

## 오늘의 도전 과제와 해결 방법
- 도전 과제 1: NoSQL의 장점, 유형 파악하기

## 오늘의 회고
- 내용이 어려워지고 있는 것 같다
- 실제로 활용해볼 일이 생겨야 감이 올 것 같다

## 참고 자료 및 링크
- 없음
